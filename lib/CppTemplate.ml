(*
  CppTemplate.ml
  --------------
  Definitions for C++ code generation template

  This module exposes:
  - functions to generate C++ source code from a lexing rule

*)

module CppTemplate = struct
  (*----------------------------------------------------------------------------*)
  (* Template initialization                                                    *)
  (*----------------------------------------------------------------------------*)

  let template = format_of_string 
{|/// ------------------------------------------------------------------------------------
/// Auto-generated by LexerGen
/// Changes made in this file will be overwritten by subsequent runs of LexerGen
/// ------------------------------------------------------------------------------------

/// header code
%s

#include <array>
#include <cstddef>
#include <string_view>

inline constexpr size_t NUM_CASES = %d;
inline constexpr size_t NO_TAG = NUM_CASES+1;

/// state->symbol->char transition lookup table
%s

/// state->tag lookup table 
%s 

/// case tag fns 
%s

inline %s __lexgen_caseNone([[maybe_unused]] std::string_view yytext)
{
    %s
}

/// tag->casetagfn lookup table
%s


inline size_t __traverse(std::string_view yytext, size_t& yyindex) {
    size_t tag = NO_TAG;
    for (size_t state = %d;state != %d && yyindex < yytext.size(); state = __ttable[state][yytext[yyindex++]])
    { 
        tag = (__ctable[state] == NO_TAG ? tag : __ctable[state]);
    }
    return tag;
}

inline %s %s(std::string_view yytext, size_t& yyindex)
{
    if (yyindex >= yytext.size())
    {
      %s
    }
    else
    {
      size_t start = yyindex;
      size_t tag = __traverse(yytext, yyindex);
      std::string_view substr = yytext.substr(start, yyindex-start);
      return __atable[tag](substr);
    }
}

%s
|} 
  (*----------------------------------------------------------------------------*)
  (* Module Initialization                                                      *)
  (*----------------------------------------------------------------------------*)
  
  open MyParsing
  open CodeGen
  
  (*----------------------------------------------------------------------------*)
  (* Function Definitions                                                       *)
  (*----------------------------------------------------------------------------*)

  let ttable_gen ( ttable : CodeGen.ttable ) : string =
    let row_to_str ( row : int array ) : string =
      let elems = Array.map string_of_int row in
      let inner = String.concat "," ( Array.to_list elems ) in
      Printf.sprintf "{%s}" inner in
    let rows = Array.map row_to_str ttable in
    let body = String.concat ",\n" ( Array.to_list rows ) in
    Printf.sprintf "inline constexpr std::array<std::array<size_t, %d>, %d> __ttable = {{\n%s\n}};" 
      (Array.length ttable.(0)) (Array.length ttable) body

  let ctable_gen ( ctable : CodeGen.ctable ) : string = 
    let elems = Array.map (fun i -> if i != -1 then string_of_int i else "NO_TAG") ctable in
    let count = Array.length ctable in 
    let inner = String.concat ", " ( Array.to_list elems ) in
    Printf.sprintf "inline constexpr std::array<size_t, %d> __ctable = {%s};" count inner 

  let atable_gen ( numCases : int ) (return_type : string ): string =
    let fn_ptr_list = List.init numCases (fun i -> Printf.sprintf "__lexgen_case%d" i) in
    let fn_ptrs = String.concat ", " fn_ptr_list in
    Printf.sprintf "inline constexpr std::array<%s(*)(std::string_view), NUM_CASES+1> __atable = { %s, __lexgen_caseNone};" 
      return_type fn_ptrs

  let action_fn_gen ( return_type : string ) ( caseIndex : int ) ( case : MyParsing.case ) : string =
    let alias_string = if String.length case.alias != 0 then case.alias else "" in
    Printf.sprintf "inline %s __lexgen_case%d(std::string_view %s) {%s}" 
      return_type caseIndex alias_string case.code

  let gen_template ( ctx : CodeGen.source_context) : string =
    let ttable_str = ttable_gen ctx.ttable in 
    let ctable_str = ctable_gen ctx.ctable in
    let lex_file = ctx.lex_file in
    let rule = lex_file.rule in
    let return_type = rule.return_type in 
    let action_strings = List.mapi (action_fn_gen return_type) rule.cases in
    let action_strings = String.concat "\n" action_strings in
    let num_cases = List.length rule.cases in
    let atable_str = atable_gen num_cases return_type in 
    Printf.sprintf template  
      lex_file.header  num_cases  ttable_str  ctable_str  action_strings  return_type  rule.none_code
      atable_str  ctx.start ctx.dead  return_type  rule.name  rule.eof_code  lex_file.trailer
      

  let context ( out_file : string ) : CodeGen.gen_context = 
    {
      out_file = out_file;
      gen_function = gen_template;
    }

end